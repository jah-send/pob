<?xml version="1.0" encoding="ISO-8859-1"?>
<grammar name="Basic">

	<syntax>
		<comment token=";"/>
	</syntax>

	<!-- Tokens' list -->
	<symbols>
		<symbol>
			<token>=</token>
			<value>EQ</value>
		</symbol>
		<symbol>
			<token>&lt;&gt;</token>
			<value>NE</value>
		</symbol>
		<symbol>
			<token>&lt;=</token>
			<value>LE</value>
		</symbol>
		<symbol>
			<token>&gt;</token>
			<value>GT</value>
		</symbol>
		<symbol>
			<token>&gt;=</token>
			<value>GE</value>
		</symbol>
		<symbol>
			<token>&lt;</token>
			<value>LT</value>
		</symbol>
		<symbol>
			<token>+</token>
			<value>PLUS</value>
		</symbol>
		<symbol>
			<token>-</token>
			<value>MINUS</value>
		</symbol>
		<symbol>
			<token>*</token>
			<value>MULT</value>
		</symbol>
		<symbol>
			<token>+=</token>
			<value>PLUSEQ</value>
		</symbol>
		<symbol>
			<token>/</token>
			<value>DIVIDE</value>
		</symbol>
		<symbol>
			<token>&amp;</token>
			<value>BAND</value>
		</symbol>
		<symbol>
			<token>|</token>
			<value>BOR</value>
		</symbol>
		<symbol>
			<token>!</token>
			<value>BXOR</value>
		</symbol>
		<symbol>
			<token>\</token>
			<value>BKSLASH</value>
		</symbol>
		<symbol>
			<token>(</token>
			<value>LPAREN</value>
		</symbol>
		<symbol>
			<token>)</token>
			<value>RPAREN</value>
		</symbol>
		<symbol>
			<token>[</token>
			<value>LBRACK</value>
		</symbol>	
		<symbol>
			<token>]</token>
			<value>RBRACK</value>
		</symbol>	
		<symbol>
			<token>,</token>
			<value>COMMA</value>
		</symbol>
		<symbol>
			<token>.</token>
			<value>DOT</value>
		</symbol>		
		<symbol>
			<token>%</token>
			<value>MODULO</value>
		</symbol>	
		<symbol>
			<token>~</token>
			<value>BNOT</value>
		</symbol>	
		<symbol>
			<token>&lt;&lt;</token>
			<value>LOFF</value>
		</symbol>	
		<symbol>
			<token>&gt;&gt;</token>
			<value>ROFF</value>
		</symbol>	
		<symbol>
			<token>:</token>
			<value>COLON</value>
		</symbol>	
		<symbol>
			<token>If</token>
			<value>IF</value>
		</symbol>
		<symbol>
			<token>Else</token>
			<value>ELSE</value>
		</symbol>
		<symbol>
			<token>ElseIf</token>
			<value>ELSEIF</value>
		</symbol>
		<symbol>
			<token>EndIf</token>
			<value>ENDIF</value>
		</symbol>
		<symbol>
			<token>While</token>
			<value>WHILE</value>
		</symbol>
		<symbol>
			<token>Wend</token>
			<value>WEND</value>
		</symbol>
		<symbol>
			<token>Select</token>
			<value>SELECT</value>
		</symbol>
		<symbol>
			<token>Case</token>
			<value>CASE</value>
		</symbol>
		<symbol>
			<token>Default</token>
			<value>DEFAULT</value>
		</symbol>
		<symbol>
			<token>EndSelect</token>
			<value>ENDSEL</value>
		</symbol>
		<symbol>
			<token>For</token>
			<value>FOR</value>
		</symbol>
		<symbol>
			<token>To</token>
			<value>TO</value>
		</symbol>
		<symbol>
			<token>Step</token>
			<value>STEP</value>
		</symbol>
		<symbol>
			<token>Next</token>
			<value>NEXT</value>
		</symbol>
		<symbol>
			<token>Repeat</token>
			<value>REPEAT</value>
		</symbol>
		<symbol>
			<token>Until</token>
			<value>UNTIL</value>
		</symbol>
		<symbol>
			<token>Declare</token>
			<value>DECLARE</value>
		</symbol>
		<symbol>
			<token>Global</token>
			<value>GLOBAL</value>
		</symbol>
		<symbol>
			<token>Static</token>
			<value>STATIC</value>
		</symbol>
		<symbol>
			<token>Const</token>
			<value>CONST</value>
		</symbol>
		<symbol>
			<token>Structure</token>
			<value>STRUCT</value>
		</symbol>
		<symbol>
			<token>EndStructure</token>
			<value>ENDSTRUCT</value>
		</symbol>
		<symbol>
			<token>And</token>
			<value>AND</value>
		</symbol>
		<symbol>
			<token>Or</token>
			<value>OR</value>
		</symbol>
		<symbol>
			<token>Xor</token>
			<value>XOR</value>
		</symbol>
		<symbol>
			<token>Not</token>
			<value>NOT</value>
		</symbol>
		<symbol>
			<token>Goto</token>
			<value>GOTO</value>
		</symbol>
		<symbol>
			<token>End</token>
			<value>END</value>
		</symbol>
		<symbol>
			<token>Break</token>
			<value>BREAK</value>
		</symbol>
		<symbol>
			<token>Continue</token>
			<value>CONTINUE</value>
		</symbol>
		<symbol>
			<token>Procedure</token>
			<value>PROCEDURE</value>
		</symbol>
		<symbol>
			<token>ProcedureMain</token>
			<value>PROCMAIN</value>
		</symbol>
		<symbol>
			<token>EndProcedure</token>
			<value>ENDPROC</value>
		</symbol>
		<symbol>
			<token>ProcedureReturn</token>
			<value>PROCRET</value>
		</symbol>
		<symbol>
			<token>Dim</token>
			<value>DIM</value>
		</symbol>	
	</symbols>
	
	<!-- Grammar's types -->
	<types>
		<type>
			<lng>b</lng>
			<c>byte</c>
		</type>	
		<type>
			<lng>f</lng>
			<c>float</c>
		</type>	
		<type>
			<lng>l</lng>
			<c>int</c>
		</type>	
		<type>
			<lng>s</lng>
			<c>string</c>
		</type>	
		<type>
			<lng>w</lng>
			<c>short</c>
		</type>	
	</types>
	
	<!-- Grammar rules -->
	<rules>
		<rule name="affelt" lbl="assigned value">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">EQ</token>
					<token num="2" terminal="0">expression</token>
				</elements>
				<function name="elt_affect">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="affstmt" lbl="assignment statement">
			<structure>
				<elements>
					<token num="1" terminal="0">decstmt</token>
				</elements>
				<function name="stmt_affdec">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">dimdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure lbl="asignment" block="2">
				<elements>
					<token num="1" terminal="0">designator</token>
					<token num="2" terminal="1">EQ</token>
					<token num="3" terminal="0">expression</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="stmt_affect">
					<arg>1</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="argdef" lbl="argument definition">
			<structure>
				<elements block="1">
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">NOSPACE</token>
					<token num="3" terminal="0">typedef</token>
					<token num="4" terminal="0">*argdefelt</token>
				</elements>
				<function name="def_arg">
					<arg>1</arg>
					<arg>3</arg>
					<arg>4</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="argdefelt" lbl="argument definition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">COMMA</token>
					<token num="2" terminal="1">NAME</token>
					<token num="3" terminal="1">NOSPACE</token>
					<token num="4" terminal="0">typedef</token>
				</elements>
				<function name="elt_arg">
					<arg>2</arg>
					<arg>4</arg>
				</function>
			</structure>
		</rule>

		<rule name="argstmt" lbl="argument">
			<structure>
				<elements>
					<token num="1" terminal="0">expression</token>
					<token num="2" terminal="1">*argeltstmt</token>
				</elements>
				<function name="stmt_argument">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="argeltstmt" lbl="argument">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">COMMA</token>
					<token num="2" terminal="0">expression</token>
				</elements>
				<function name="elt_argument">
					<arg>2</arg>
				</function>
			</structure>
		</rule>

		<rule name="brkstmt" lbl="break statement">
			<structure>
				<elements>
					<token num="1" terminal="1">BREAK</token>
					<token num="2" terminal="1">CR</token>
				</elements>
				<function name="stmt_break"/>
			</structure>
		</rule>	
		
		<rule name="callexpr" lbl="call statement expression">
			<structure block="2">
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">LPAREN</token>
					<token num="3" terminal="0">?argstmt</token>
					<token num="4" terminal="1">RPAREN</token>
				</elements>
				<function name="stmt_call">
					<arg>1</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="callstmt" lbl="call statement">
			<structure block="2">
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">LPAREN</token>
					<token num="3" terminal="0">?argstmt</token>
					<token num="4" terminal="1">RPAREN</token>
					<token num="5" terminal="1">CR</token>
				</elements>
				<function name="stmt_call">
					<arg>1</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="casestmt" lbl="case block">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">CASE</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">expression</token>
					<token num="4" terminal="1">CR</token>
					<token num="5" terminal="0">+stmt</token>
				</elements>
				<function name="stmt_case">
					<arg>3</arg>
					<arg>5</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="condition" lbl="condition">
			<structure>
				<elements>
					<token num="1" terminal="0">cond1</token>
					<token num="2" terminal="0">*condelt</token>
				</elements>
				<function name="cond_condition">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="cond1" lbl="condition">
			<structure>
				<elements>
					<token num="1" terminal="0">cond2</token>
					<token num="2" terminal="0">*condelt1</token>
				</elements>
				<function name="cond_condition">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="cond2" lbl="condition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">NOT</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_not">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LPAREN</token>
					<token num="2" terminal="0">condition</token>
					<token num="3" terminal="1">RPAREN</token>
				</elements>
				<function name="cond_paren">
					<arg>2</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">expression</token>
				</elements>
				<function name="cond_expr">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="condelt" lbl="condition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">AND</token>
					<token num="2" terminal="0">cond1</token>
				</elements>
				<function name="cond_and">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">OR</token>
					<token num="2" terminal="0">cond1</token>
				</elements>
				<function name="cond_or">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">XOR</token>
					<token num="2" terminal="0">cond1</token>
				</elements>
				<function name="cond_xor">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="condelt1" lbl="condition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">EQ</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_equal">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">NE</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_nequal">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">GT</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_gthan">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">GE</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_gequal">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LT</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_lthan">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LE</token>
					<token num="2" terminal="0">cond2</token>
				</elements>
				<function name="cond_lequal">
					<arg>2</arg>
				</function>
			</structure>
		</rule>

		<rule name="constmt" lbl="constant declaration">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">CONST</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">decstmt</token>
				</elements>
				<function name="def_const">
					<arg>3</arg>
				</function>
			</structure>
		</rule>

		<rule name="ctnstmt" lbl="continue statement">	
			<structure>
				<elements>
					<token num="1" terminal="1">CONTINUE</token>
					<token num="2" terminal="1">CR</token>
				</elements>
				<function name="stmt_continue"/>
			</structure>
		</rule>	

		<rule name="decdef" lbl="function declare">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">DECLARE</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="1">NAME</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="def_declare">
					<arg>3</arg>
				</function>
			</structure>
		</rule>

		<rule name="decstmt" lbl="variable declation">
			<structure block="3">
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">?typedef</token>
					<token num="3" terminal="1">affelt</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="stmt_declare">
					<arg>1</arg>
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
			<structure block="3">
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">NOSPACE</token>
					<token num="3" terminal="1">typedef</token>
					<token num="4" terminal="1">*affelt</token>
					<token num="5" terminal="1">CR</token>
				</elements>
				<function name="stmt_declare">
					<arg>1</arg>
					<arg>3</arg>
					<arg>4</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="defstmt" lbl="default block">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">DEFAULT</token>
					<token num="2" terminal="1">CR</token>
					<token num="3" terminal="0">+stmt</token>
				</elements>
				<function name="stmt_default">
					<arg>3</arg>
				</function>
			</structure>
		</rule>

		<rule name="desdim" lbl="array definition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LBRACK</token>
					<token num="2" terminal="0">expression</token>
					<token num="3" terminal="1">*dimargelt</token>
					<token num="4" terminal="1">RBRACK</token>
				</elements>
				<function name="stmt_argdim">
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="desdimval" lbl="array value">
			<structure block="1">
				<elements>  
					<token num="1" terminal="1">LBRACK</token>
					<token num="2" terminal="0">expression</token>
					<token num="3" terminal="0">*dimargelt</token>
					<token num="4" terminal="1">RBRACK</token>
				</elements>
				<function name="val_argdim">
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="designator" lbl="designator">
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="0">?desdim</token>
					<token num="3" terminal="0">?desstr</token>
				</elements>
				<function name="stmt_design">
					<arg>1</arg>
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="designval" lbl="designator value">
			<structure>
				<elements>  
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">?desdimval</token>
					<token num="3" terminal="0">?desstr</token>
				</elements>
				<function name="val_design">
					<arg>1</arg>
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="desstr" lbl="structure field">
			<structure block="2">
				<elements>
					<token num="1" terminal="1">NOSPACE</token>
					<token num="2" terminal="1">BKSLASH</token>
					<token num="3" terminal="1">NOSPACE</token>
					<token num="4" terminal="1">NAME</token>
				</elements>
				<function name="stmt_strelt">
					<arg>4</arg>
				</function>
			</structure>
		</rule>

		<rule name="dimargdef" lbl="array definition">
			<structure>
				<elements>
					<token num="1" terminal="0">expression</token>
					<token num="2" terminal="1">*dimargelt</token>
				</elements>
				<function name="def_argdim">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="dimargelt" lbl="array definition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">COMMA</token>
					<token num="2" terminal="0">expression</token>
				</elements>
				<function name="elt_argdim">
					<arg>2</arg>
				</function>
			</structure>
		</rule>

		<rule name="dimdef" lbl="array definition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">DIM</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="1">NAME</token>
					<token num="4" terminal="1">?typedef</token>
					<token num="5" terminal="1">LBRACK</token>
					<token num="6" terminal="0">dimargdef</token>
					<token num="7" terminal="1">RBRACK</token>
					<token num="8" terminal="1">CR</token>
				</elements>
				<function name="def_dim">
					<arg>3</arg>
					<arg>4</arg>
					<arg>6</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="elifstmt" lbl="elseif block">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">ELSEIF</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">condition</token>
					<token num="4" terminal="1">CR</token>
					<token num="5" terminal="0">+stmt</token>
				</elements>
				<function name="stmt_elseif">
					<arg>3</arg>
					<arg>5</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="elsestmt" lbl="else block">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">ELSE</token>
					<token num="2" terminal="1">CR</token>
					<token num="3" terminal="0">+stmt</token>
				</elements>
				<function name="stmt_else">
					<arg>3</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="endstmt" lbl="end statement">
			<structure>
				<elements>
					<token num="1" terminal="1">END</token>
					<token num="2" terminal="1">CR</token>
				</elements>
				<function name="stmt_end"/>
			</structure>
		</rule>	

		<rule name="expression" lbl="expression">
			<structure>
				<elements>
					<token num="1" terminal="1">DQ_STRING</token>
				</elements>
				<function name="expr_string">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">Q_STRING</token>
				</elements>
				<function name="expr_char">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">expr1</token>
					<token num="2" terminal="0">*exprelt</token>
				</elements>
				<function name="expr_expression">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="expr1" lbl="expression">
			<structure>
				<elements>
					<token num="1" terminal="0">expr2</token>
					<token num="2" terminal="0">*exprelt1</token>
				</elements>
				<function name="expr_expression">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="expr2" lbl="expression">
			<structure>
				<elements>
					<token num="1" terminal="0">expr3</token>
					<token num="2" terminal="0">*exprelt2</token>
				</elements>
				<function name="expr_expression">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="expr3" lbl="expression">
			<structure>
				<elements>
					<token num="1" terminal="0">expr4</token>
					<token num="2" terminal="0">*exprelt3</token>
				</elements>
				<function name="expr_expression">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="expr4" lbl="expression">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">PLUS</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_posval">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">MINUS</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_negval">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LPAREN</token>
					<token num="2" terminal="0">expression</token>
					<token num="3" terminal="1">RPAREN</token>
				</elements>
				<function name="expr_paren">
					<arg>2</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">HEXA</token>
				</elements>
				<function name="expr_hexa">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">BINARY</token>
				</elements>
				<function name="expr_binary">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">INTEGER</token>
				</elements>
				<function name="expr_integer">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">FLOAT</token>
				</elements>
				<function name="expr_float">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>  
					<token num="1" terminal="1">callexpr</token>
				</elements>
				<function name="expr_call">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>  
					<token num="1" terminal="1">designval</token>
				</elements>
				<function name="expr_design">
					<arg>1</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">BNOT</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_bnot">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="exprelt" lbl="expression">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">PLUS</token>
					<token num="2" terminal="0">expr1</token>
				</elements>
				<function name="expr_plus">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">MINUS</token>
					<token num="2" terminal="0">expr1</token>
				</elements>
				<function name="expr_minus">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="exprelt1" lbl="expression">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">MULT</token>
					<token num="2" terminal="0">expr2</token>
				</elements>
				<function name="expr_mult">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">DIVIDE</token>
					<token num="2" terminal="0">expr2</token>
				</elements>
				<function name="expr_divide">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="exprelt2" lbl="expression">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">BAND</token>
					<token num="2" terminal="0">expr3</token>
				</elements>
				<function name="expr_band">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">BOR</token>
					<token num="2" terminal="0">expr3</token>
				</elements>
				<function name="expr_bor">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="exprelt3" lbl="expression">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">LOFF</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_loff">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">ROFF</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_roff">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">BXOR</token>
					<token num="2" terminal="0">expr4</token>
				</elements>
				<function name="expr_bxor">
					<arg>2</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">MODULO</token>
					<token num="2" terminal="0">expr3</token>
				</elements>
				<function name="expr_modulo">
					<arg>2</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="forstmt" lbl="for statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">FOR</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">forvar</token>
					<token num="4" terminal="1">EQ</token>
					<token num="5" terminal="0">expression</token>
					<token num="6" terminal="1">SPACE</token>
					<token num="7" terminal="1">TO</token>
					<token num="8" terminal="1">SPACE</token>
					<token num="9" terminal="0">expression</token>
					<token num="10" terminal="0">?stpstmt</token>
					<token num="11" terminal="1">CR</token>
					<token num="12" terminal="0">*stmt</token>
					<token num="13" terminal="1">NEXT</token>
					<token num="14" terminal="1">CR</token>
				</elements>
				<function name="stmt_for">
					<arg>3</arg>
					<arg>5</arg>
					<arg>9</arg>
					<arg>10</arg>
					<arg>12</arg>
				</function>
			</structure>
		</rule>

		<rule name="forvar" lbl="for variable">
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="0">?typedef</token>
				</elements>
				<function name="elt_forvar">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="gotostmt" lbl="goto statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">GOTO</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="1">NAME</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="stmt_goto">
					<arg>3</arg>
				</function>
			</structure>
		</rule>

		<rule name="ifstmt" lbl="if statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">IF</token>
					<token num="2" terminal="0">condition</token>
					<token num="3" terminal="1">CR</token>
					<token num="4" terminal="0">+stmt</token>
					<token num="5" terminal="0">*elifstmt</token>
					<token num="6" terminal="0">?elsestmt</token>
					<token num="7" terminal="1">ENDIF</token>
					<token num="8" terminal="1">CR</token>
				</elements>
				<function name="stmt_if">
					<arg>2</arg>
					<arg>4</arg>
					<arg>5</arg>
					<arg>6</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="lbldef" lbl="label">
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">COLON</token>
					<token num="3" terminal="1">CR</token>
				</elements>
				<function name="stmt_label">
					<arg>1</arg>
				</function>
			</structure>
		</rule>

		<rule name="procdef" lbl="function definition">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">PROCEDURE</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">procname</token>
					<token num="4" terminal="0">?typedef</token>
					<token num="5" terminal="1">LPAREN</token>
					<token num="6" terminal="0">?argdef</token>
					<token num="7" terminal="1">RPAREN</token>
					<token num="8" terminal="1">CR</token>
					<token num="9" terminal="0">*stmt</token>
					<token num="10" terminal="1">ENDPROC</token>
					<token num="11" terminal="1">CR</token>
				</elements>
				<function name="def_proc">
					<arg>3</arg>
					<arg>4</arg>
					<arg>6</arg>
					<arg>9</arg>
				</function>
			</structure>
		</rule>	
		
		<rule name="procname" lbl="function name">
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
				</elements>
				<function name="elt_procname">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">PROCMAIN</token>
				</elements>
				<function name="elt_procmain">
					<arg>1</arg>
				</function>
			</structure>
		</rule>

		<rule name="prtstmt" lbl="procedure return">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">PROCRET</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">expression</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="stmt_procret">
					<arg>3</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="repstmt" lbl="repeat statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">REPEAT</token>
					<token num="2" terminal="1">CR</token>
					<token num="3" terminal="0">+stmt</token>
					<token num="4" terminal="1">UNTIL</token>
					<token num="5" terminal="0">condition</token>
					<token num="6" terminal="1">CR</token>
				</elements>
				<function name="stmt_repeat">
					<arg>3</arg>
					<arg>5</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="selstmt" lbl="select statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">SELECT</token>
					<token num="3" terminal="0">expression</token>
					<token num="4" terminal="1">CR</token>
					<token num="5" terminal="0">*casestmt</token>
					<token num="6" terminal="1">?defstmt</token>
					<token num="7" terminal="1">ENDSEL</token>
					<token num="8" terminal="1">CR</token>
				</elements>
				<function name="stmt_select">
					<arg>2</arg>
					<arg>4</arg>
					<arg>5</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="stmt" lbl="statement">
			<structure>
				<elements>
					<token num="1" terminal="0">ifstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">whlstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">forstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">repstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">selstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">affstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">dimdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">strdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">gotostmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">brkstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">ctnstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">endstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">prtstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">lbldef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">callstmt</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="stmtseq" lbl="statement sequence">
			<structure>
				<elements>
					<token num="1" terminal="0">procdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">decdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">vardec</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">strdef</token>
				</elements>
				<function name="stmt_stmt">
					<arg>1</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="stpstmt" lbl="step block">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">STEP</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">expression</token>
				</elements>
				<function name="stmt_step">
					<arg>3</arg>
				</function>
			</structure>
		</rule>

		<rule name="strdef" lbl="structure definition">
		<structure block="1">
				<elements>
					<token num="1" terminal="1">STRUCT</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="1">NAME</token>
					<token num="4" terminal="1">CR</token>
					<token num="5" terminal="0">+strelt</token>
					<token num="6" terminal="1">ENDSTRUCT</token>
					<token num="7" terminal="1">CR</token>
				</elements>
				<function name="def_struct">
					<arg>3</arg>
					<arg>5</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="strelt" lbl="structure field definition">
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="1">?typedef</token>
					<token num="3" terminal="1">CR</token>
				</elements>
				<function name="elt_struct">
					<arg>1</arg>
					<arg>2</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="typedef" lbl="type">
			<structure block="2">
				<elements>
					<token num="1" terminal="1">NOSPACE</token>
					<token num="2" terminal="1">DOT</token>
					<token num="3" terminal="1">NOSPACE</token>
					<token num="4" terminal="1">NAME</token>
				</elements>
				<function name="elt_typedef">
					<arg>4</arg>
				</function>
			</structure>
		</rule>

		<rule name="vardec" lbl="variable declaration">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">GLOBAL</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">varstmt</token>
				</elements>
				<function name="def_glo">
					<arg>3</arg>
				</function>
			</structure>
			<structure block="1">
				<elements>
					<token num="1" terminal="1">STATIC</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">varstmt</token>
				</elements>
				<function name="def_glo">
					<arg>3</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">decstmt</token>
				</elements>
				<function name="def_glovar">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">dimdef</token>
				</elements>
				<function name="def_glo">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">constmt</token>
				</elements>
				<function name="def_glo">
					<arg>1</arg>
				</function>
			</structure>
		</rule>
		
		<rule name="varstmt" lbl="variable declaration">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">CONST</token>
					<token num="2" terminal="1">SPACE</token>
					<token num="3" terminal="0">decstmt</token>
				</elements>
				<function name="def_const">
					<arg>3</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="0">dimdef</token>
				</elements>
				<function name="def_glo">
					<arg>1</arg>
				</function>
			</structure>
			<structure>
				<elements>
					<token num="1" terminal="1">NAME</token>
					<token num="2" terminal="0">?typedef</token>
					<token num="3" terminal="0">?affelt</token>
					<token num="4" terminal="1">CR</token>
				</elements>
				<function name="def_decvar">
					<arg>1</arg>
					<arg>2</arg>
					<arg>3</arg>
				</function>
			</structure>
		</rule>
	
		<rule name="whlstmt" lbl="while statement">
			<structure block="1">
				<elements>
					<token num="1" terminal="1">WHILE</token>
					<token num="2" terminal="0">condition</token>
					<token num="3" terminal="1">CR</token>
					<token num="4" terminal="1">*stmt</token>
					<token num="5" terminal="0">WEND</token>
					<token num="6" terminal="1">CR</token>
				</elements>
				<function name="stmt_while">
					<arg>2</arg>
					<arg>4</arg>
				</function>
			</structure>
		</rule>
	</rules>
	
	<!-- Compilation orders -->
	<compile>
	
		<function name="cond_and" nbargs="3" return="1">
			<!-- RULE = condelt	-->
			<!-- evaluate a condition AND -->
			
			<!-- ARG 1  :  right side of AND		-->
			<!-- ARG 2  :  left side of AND 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from AND condition ** -->
			<instruction name="iand">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_condition" nbargs="3" return="1">
			<!-- RULE = condition, eval1 -->
			<!-- evaluation of a condition -->
			
			<!-- ARG 1  : left side of the condition 	-->
			<!-- ARG 2*  : right side of the condition  -->
			<!-- ARG 3?  : register to store the value  -->
			<!-- RETURN : register storing the result 	-->
					
			<!-- ** var1 = register to store (if unknown, new one) ** -->
			<instruction name="">
				<arg>argdefault 3 var1</arg>
			</instruction>
			<!-- ** reg1 = evaluated condition ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1 var1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- next conditions -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<!-- if last, it will be stored in the known reg -->
			<instruction name="">
				<arg>iflast 2</arg>
			</instruction>
			<!-- ** reg2 = evaluated condition ** -->
			<instruction name="">
				<arg>argeval2 2 reg1 reg1 var1</arg>
			</instruction>
			<!-- else, it will be stored in a new reg -->
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argeval2 2 reg1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="cond_equal" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition EQUAL	-->
			
			<!-- ARG 1  :  right side of EQUAL		-->
			<!-- ARG 2  :  left side of EQUAL 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from EQUAL condition ** -->
			<instruction name="cmpeq">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_expr" nbargs="3" return="1">
			<!-- RULE = eval2 -->
			<!-- expression part of a condition	-->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of condition	-->
			
			<!-- ** reg2 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = evaluated expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1 reg2</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="cond_gequal" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition GT or EQ -->
			
			<!-- ARG 1  :  right side of GT or EQ	-->
			<!-- ARG 2  :  left side of GT or EQ	-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from GT or EQ condition ** -->
			<instruction name="cmpge">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_gthan" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition GT -->
			
			<!-- ARG 1  :  right side of GT			-->
			<!-- ARG 2  :  left side of GT			-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from GT condition ** -->
			<instruction name="cmpgt">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_lequal" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition LT or EQ -->
			
			<!-- ARG 1  :  right side of LT or EQ	-->
			<!-- ARG 2  :  left side of LT or EQ	-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from LT or EQ condition ** -->
			<instruction name="cmple">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_lthan" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition LT -->
			
			<!-- ARG 1  :  right side of LT			-->
			<!-- ARG 2  :  left side of LT			-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from LT condition ** -->
			<instruction name="cmplt">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_nequal" nbargs="3" return="1">
			<!-- RULE = condelt1 -->
			<!-- evaluate a condition NOT EQUAL -->
			
			<!-- ARG 1  :  right side of NOT EQUAL	-->
			<!-- ARG 2  :  left side of NOT EQUAL 	-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from !EQUAL condition ** -->
			<instruction name="cmpne">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_not" nbargs="3" return="1">
			<!-- RULE = eval2 -->
			<!-- not a condition -->
			
			<!-- ARG 1  :  condition				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of condition	-->
			
			<!-- ** reg2 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- not the condition -->
			<instruction name="inot">
				<arg>reg2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_or" nbargs="3" return="1">
			<!-- RULE = condelt	-->
			<!-- evaluate a condition OR -->
			
			<!-- ARG 1  :  right side of OR			-->
			<!-- ARG 2  :  left side of OR 			-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from OR condition ** -->
			<instruction name="ior">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="cond_paren" nbargs="3" return="1">
			<!-- RULE = eval2 -->
			<!-- evaluate a condition in parenthesis -->
			
			<!-- ARG 1  : condition to evaluate 		-->
			<!-- RETURN : register storing the result  	-->			
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="cond_xor" nbargs="3" return="1">
			<!-- RULE = condelt	-->
			<!-- evaluate a condition XOR -->
			
			<!-- ARG 1  :  right side of XOR		-->
			<!-- ARG 2  :  left side of XOR 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = condition's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from XOR condition ** -->
			<instruction name="ixor">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="def_arg" nbargs="3" return="1">
			<!-- RULE = argdef -->
			<!-- argument of a function (declare) -->
			
			<!-- ARG 1  : name of the argument	-->
			<!-- ARG 2  : type of the argument	-->
			<!-- ARG 3* : following arguments  	-->
			<!-- RETURN : number of arguments 	-->

			<!-- ** cpt1 = counter of args (for register) ** -->
			<instruction name="">
				<arg>argcpt 3 cpt1</arg>
			</instruction>
			<instruction name="">
				<arg>varinc cpt1</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<!-- create a new Local variable -->
			<instruction name="">
				<arg>newvar var2 1 var1 L</arg>
			</instruction>
			<instruction name="">
				<arg>loop 3</arg>
			</instruction>
			<!-- ## call : elt_arg (function's arguments) ## -->
			<instruction name="">
				<arg>argcall 3</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<return>cpt1</return>
		</function>
		
		<function name="def_argdim" nbargs="5" return="1">
			<!-- RULE = dimargdef -->
			<!-- definition of dim arguments (array) -->
			
			<!-- ARG 1  :  first dimension		-->
			<!-- ARG 2*  :  next dimensions		-->
			<!-- ARG 3  :  array's name			-->
			<!-- ARG 4  :  data type			-->
			<!-- ARG 5? :  is local or static	-->
			<!-- RETURN :  register of the created object  	-->
			
			<!-- COMPILE : array already exists -->
			<instruction name="">
				<arg>redefvar 3</arg>   
			</instruction>
			<!-- ** var1 = data type ** -->
			<instruction name="">
				<arg>argdefault 4 var1 int</arg>   
			</instruction>
			<!-- ** var2 = number of arguments ** -->
			<instruction name="">
				<arg>argcpt 2 var2</arg>        
			</instruction>
			<!-- add 1 for the first argument -->
			<instruction name="">
				<arg>varinc var2</arg>        	
			</instruction>
			<!-- ** var3 = global or not ** -->
			<instruction name="">
				<arg>argdefault 5 var3 L</arg>   
			</instruction>
			<!-- ** reg1 = register where the array will be stored ** -->
			<instruction name="">				
				<arg>codetmpreg reg1</arg>			
			</instruction>
			<!-- creation of the array in the code -->
			<instruction name="">
				<arg>newarray 3 var1 var2 var3 reg1</arg>
			</instruction>
			<!-- ** cpt1 : parameters' counter ** -->
			<instruction name="">				
				<arg>varinit cpt1 0</arg>		
			</instruction>
			<!-- ** reg3 : dimension's evaluation ** -->
			<instruction name="">				
				<arg>argeval1 1 reg3</arg>			
			</instruction>
			<instruction name="">				
				<arg>setarrdim 3 cpt1 reg3</arg>	
			</instruction>
			
			<instruction name="">				
				<arg>varinit var4 1</arg>			
			</instruction>
			<!-- one-dimension array -->
			<instruction name="">				
				<arg>ifequal var2 var4</arg>		
			</instruction>
			<instruction name="newarray">
				<arg>reg1</arg>					
				<arg>reg3</arg>
				<arg>var1</arg>
			</instruction>
			<instruction name="">				
				<arg>varinit var6 array</arg>		
			</instruction>
			
			<!-- set the array's first dimension -->
			<instruction name="">				
				<arg>else</arg>		
			</instruction>
			<instruction name="">				
				<arg>varinit var6 str_dim</arg>		
			</instruction>
			<instruction name="new">
				<arg>reg1</arg>					
				<arg>var6</arg>
			</instruction>
			<!-- ** reg2 : dimensions' array ** -->
			<instruction name="">				
				<arg>codetmpreg reg2</arg>			
			</instruction>
			<instruction name="newarray">				
				<arg>reg2</arg>					
				<arg>var2</arg>
			</instruction>
			<!-- set the array's first dimension -->
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<!-- same for the other dimensions -->
			<instruction name="">
				<arg>loop 2</arg>				
			</instruction>
			<instruction name="">				
				<arg>varinc cpt1</arg>			
			</instruction>
			<!-- ## reg3 = elt_argdim ## -->
			<instruction name="">				
				<arg>arggetval 2 reg3</arg>		
			</instruction>
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<instruction name="">				
				<arg>setarrdim 3 cpt1 reg3</arg>	
			</instruction>
			<!-- end loop other dimensions -->
			<instruction name="">
				<arg>endloop</arg>				
			</instruction>
			<!-- set parameters for function init -->
			<!-- registers for the functions' arguments -->
			<instruction name="">
				<arg>varinit reg-2 r-2</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg-1 r-1</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg-0 r-0</arg>	
			</instruction>
			<!-- starting parameters -->
			<instruction name="nop"/>
			<!-- arg1 => number of parameters -->
			<instruction name="iload">
				<arg>reg-2</arg>						
				<arg>var2</arg>
			</instruction>
			<!-- arg2 => dimensions' list -->
			<instruction name="load">
				<arg>reg-1</arg>							
				<arg>reg2</arg>
			</instruction>
			<!-- arg3 => aray's data type -->
			<instruction name="baload">
				<arg>reg-0</arg>						
				<arg>var1</arg>
			</instruction>
			<!-- call of code init -->
			<instruction name="">				
				<arg>varinit var5 str_dim.init</arg>		
			</instruction>
			<instruction name="call">
				<arg>var5</arg>
				<arg>reg1</arg>
			</instruction>
			<instruction name="">				
				<arg>endif</arg>		
			</instruction>
			
			<!-- if the dim is static, set the field -->
			<instruction name="">				
				<arg>ifequal var3 S</arg>		
			</instruction>
			<instruction name="">				
				<arg>getidstatic var1 3</arg>		
			</instruction>
			<instruction name="setstatic">
				<arg>reg1</arg>
				<arg>var1</arg>
			</instruction>
			<instruction name="">				
				<arg>endif</arg>		
			</instruction>
			
			<return>reg1</return>
		</function>

		<function name="def_const" nbargs="2" return="0">
			<!-- RULE = constmt, varstmt -->
			<!-- call child function with the argument "const"	-->
			<!-- ARG 1  :  	function to call	-->
			<!-- ARG 2  :  	global or not		-->
			
			<!-- ## call : stmt_declare ## -->
			<instruction name="">
				<arg>argcall 1 2 O</arg>
			</instruction>
		</function>

		<function name="def_declare" nbargs="1" return="0">
			<!-- RULE = decdef -->
			<!-- Declare a function before its definition	-->
			<!-- ARG 1  :  function to declare		-->
			<instruction name="">
				<arg>newfct 1</arg>
			</instruction>
		</function>
		
		<function name="def_decvar" nbargs="4" return="0">
			<!-- RULE = varstmt -->
			<!-- Function to declare and/or affect a variable -->
			
			<!-- ARG 1  :  name of the variable		-->
			<!-- ARG 2? :  type of the variable		-->
			<!-- ARG 3? :  left of the expression  	-->
			<!-- ARG 4  :  global or not   			-->
		
			<!-- ** reg1 = type of the variable (int by default) ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = evaluated expression (if it exists) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<!-- ## reg1 = elt_affect ## -->
			<instruction name="">
				<arg>arggetval 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<!-- create a variable without the register -->
			<instruction name="">
				<arg>varinit reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- create a variable with the register -->
			<instruction name="">
				<arg>setvar var2 1 var1 4 N reg1</arg>
			</instruction>
			<!-- if the variable is a static, affectation -->
			<instruction name="">
				<arg>ifequal 4 S</arg>
			</instruction>
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>getidstatic var3 1</arg>
			</instruction>
			<instruction name="setstatic">
				<arg>reg1</arg>
				<arg>var3</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
		</function>
	
		<function name="def_dim" nbargs="4" return="0">
			<!-- RULE = dimdef	 -->
			<!-- define an array -->
			
			<!-- ARG 1  :  array's name		-->
			<!-- ARG 2  :  data type	 	-->
			<!-- ARG 3  :  dimensions	 	-->
			<!-- ARG 4? :  Static or Local	-->
			
			<!-- ** var1 = data type ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 4 var2 L</arg>
			</instruction>
			<!-- ## reg1 = def_argdim ## -->
			<instruction name="">
				<arg>arggetval 3 reg1 1 var1 var2</arg>
			</instruction>
		</function>
		
		<function name="def_glo" nbargs="1" return="0">
			<!-- RULE = vardec, varstmt -->
			<!-- call child function with the argument "global"	-->
			<!-- ARG 1  :  	function to call	-->
			
			<!-- ## call : declaration function ## -->
			<instruction name="">
				<arg>argcall 1 S</arg>
			</instruction>
		</function>
		
		<function name="def_glovar" nbargs="1" return="0">
			<!-- RULE = vardec -->
			<!-- call with arguments "global" and not "constant" -->
			<!-- ARG 1  :  	function to call	-->
			
			<!-- ## call : stmt_declare ## -->
			<instruction name="">
				<arg>argcall 1 S N</arg>
			</instruction>
		</function>
		
		<function name="def_proc" nbargs="4" return="0">
			<!-- RULE = procdef -->
			<!-- create a function with its content	-->
			
			<!-- ARG 1  : name of the function	-->
			<!-- ARG 2? : type of return  		-->
			<!-- ARG 3? : list of arguments   	-->
			<!-- ARG 4* : statements to execute	-->

			<!-- ## var1 = elt_code (name/main) ## -->
			<instruction name="">
				<arg>arggetval 1 var1</arg>
			</instruction>
			<!-- COMPILE : function already exists -->
			<instruction name="">
				<arg>redeffct var1</arg>
			</instruction>
			<!-- ** var2 = type of return ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var2 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var2 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>			
			<!-- create a code -->
			<instruction name="">
				<arg>newcode var1 var2 O</arg>
			</instruction>
			<!-- there are arguments -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<!-- ## var3 = def_arg ## -->
			<instruction name="">
				<arg>arggetval 3 var3</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var3 0</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- set the number of arguments -->
			<instruction name="">
				<arg>codesetargs var3</arg>
			</instruction>
			<instruction name="">
				<arg>loop 4</arg>
			</instruction>
			<!-- ## call : stmt (every statement) ## -->
			<instruction name="">
				<arg>argcall 4</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- put all the correct registers for codes' calls -->
			<instruction name="">
				<arg>codeclose</arg>
			</instruction>
		</function>

		<function name="def_struct" nbargs="2" return="0">
			<!-- RULE = strdef -->
			<!-- define a structure -->
			<!-- ARG 1  : name of the structure	-->
			<!-- ARG 2+ : structure's fields  	-->
			
			<!-- COMPILE : structure already exists -->
			<instruction name="">
				<arg>redefstr 1</arg>
			</instruction>
			<instruction name="">
				<arg>newseg 1 N</arg>
			</instruction>
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<!-- ## call : elt_struct (structure's fields) ## -->
			<instruction name="">
				<arg>argcall 2 1</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
		</function>

		<function name="elt_affect" nbargs="2" return="1">
			<!-- RULE = affelt -->
			<!-- Right side of an affectation (expression) -->
			
			<!-- ARG 1  :  expression to evaluate		-->
			<!-- ARG 2?  : register to store the value	-->
			<!-- RETURN :  evaluated expression  		-->
			<instruction name="">
				<arg>argdefault 2 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1 reg2</arg>
			</instruction>
			<return>reg1</return>
		</function>
	
		<function name="elt_arg" nbargs="2" return="0">
			<!-- RULE = argdefelt -->
			<!-- argument of a function (declare)	-->
			<!-- ARG 1  : name of the argument		-->
			<!-- ARG 2  : type of the argument		-->
			
			<!-- COMPILE : argument already exists -->
			<instruction name="">
				<arg>redefvar 1</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<!-- create a new local variable -->
			<instruction name="">
				<arg>newvar var2 1 var1 L</arg>
			</instruction>
		</function>
		
		<function name="elt_argdim" nbargs="1" return="1">
			<!-- RULE = dimargelt -->
			<!--  function to get a index in the tab -->
			
			<!-- ARG 1  :  dimension			-->
			<!-- RETURN :  the evaluated index  -->
			
			<!-- expression's evaluation -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- register that contains the evaluated expression -->
			<return>reg1</return>
		</function>
		
		<function name="elt_argument" nbargs="2" return="0">
			<!-- RULE = argeltstmt -->
			<!-- argument for calling a function -->
			
			<!-- ARG 1  : expression to evaluate 		-->
			<!-- ARG 2  : register where to store	  	-->
			
			<!-- ** reg1 = evaluated expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1 2</arg>
			</instruction>
			<!-- if registers are different, loading -->
			<instruction name="">
				<arg>ifequal reg1 2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="load">
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
		</function>
		
		<function name="elt_forvar" nbargs="2" return="1">
			<!-- RULE = forvar -->
			<!-- create a variable for the for iterations 	-->
			<!-- ARG 1  : name of the variable 		-->
			<!-- ARG 2? : type of the variable  	-->
			<!-- RETURN : variable's register   	-->
			
			<!-- ** var1 = type of the variable (int by default) ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- create the variable if it doesn't exist -->
			<instruction name="">
				<arg>newvar var2 1 var1 L</arg>
			</instruction>
			<!-- ** reg1 = variable's register ** -->
			<instruction name="">
				<arg>getidvar reg1 1</arg>
			</instruction>
			<!-- if not creation, we check it's not a constant -->
			<instruction name="">
				<arg>ifequal var2 N</arg>
			</instruction>
			<instruction name="">
				<arg>isconst 1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="elt_procmain" nbargs="1" return="1">
			<!-- RULE = procname (main case) -->
			<!-- ARG 1  : name of the procedure -->
			<!-- RETURN : main (procedure main)	-->
			
			<!-- procedure main -->
			<return>main</return>
		</function>
		
		<function name="elt_procname" nbargs="1" return="1">
			<!-- RULE = procname (normal case)  -->
			<!-- ARG 1  : name of the procedure -->
			<!-- RETURN : procedure's name	    -->
			
			<!-- name's procedure -->
			<return>1</return>
		</function>
		
		<function name="elt_struct" nbargs="3" return="0">
			<!-- RULE = strelt -->
			<!-- define a structure's field	-->
			
			<!-- ARG 1  : name of the field		-->
			<!-- ARG 2? : type of the field  	-->
			<!-- ARG 3  : name of the structure	-->
			
			<!-- COMPILE : existing field -->
			<instruction name="">
				<arg>redefstrfd 1 3</arg>
			</instruction>
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 2 var1 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- creation of a field in structure's segment -->
			<instruction name="">
				<arg>newfield 3 1 var1</arg>
			</instruction>
		</function>

		<function name="elt_typedef" nbargs="1" return="1">
			<!-- RULE = typedef -->
			<!-- function to get the type of a variable	-->
			
			<!-- ARG 1  :  type of the variable		-->
			<!-- RETURN :  type for the bapp file  	-->

			<instruction name="">
				<arg>type var1 1</arg>
			</instruction>
			<return>var1</return>
		</function>

		<function name="expr_binary" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get a binary expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="iload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="expr_band" nbargs="3" return="1">
			<!-- RULE = exprelt2 -->
			<!-- evaluate an expression BAND -->
			
			<!-- ARG 1  :  right side of BAND		-->
			<!-- ARG 2  :  left side of BAND 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 2 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from BAND expression ** -->
			<instruction name="iand">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_bnot" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- not an expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of condition	-->
			
			<!-- ** reg2 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1 reg2</arg>
			</instruction>
			<!-- not the expression -->
			<instruction name="inot">
				<arg>reg2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
	
		<function name="expr_bor" nbargs="3" return="1">
			<!-- RULE = exprelt2 -->
			<!-- evaluate an expression BOR	-->
			
			<!-- ARG 1  :  right side of BOR		-->
			<!-- ARG 2  :  left side of BOR 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from BOR expression ** -->
			<instruction name="ior">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_bxor" nbargs="3" return="1">
			<!-- RULE = exprelt3 -->
			<!-- evaluate an expression BXOR		-->
			
			<!-- ARG 1  :  right side of BXOR		-->
			<!-- ARG 2  :  left side of BXOR 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from BXOR expression ** -->
			<instruction name="ixor">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>

		<function name="expr_call" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get the returned value of a function as an expression -->
			
			<!-- ARG 1  :  function to call (with its args)	-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ## call : stmt_call (call a function) ## -->
			<instruction name="">
				<arg>argcall 1</arg>
			</instruction>
			<!-- ** reg+1 = function's returned value ** -->
			<instruction name="">
				<arg>varinit reg+1 r+1</arg>
			</instruction>
			<instruction name="load">
				<arg>reg1</arg>
				<arg>reg+1</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="expr_char" nbargs="3" return="1">
			<!-- RULE = expression -->
			<!-- get string expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- check if there's only one character -->
			<instruction name="">
				<arg>ischar 1</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="iload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="expr_design" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get the value of a designator -->
			
			<!-- ARG 1  :  designator			-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ## reg1 = val_design ## -->
			<instruction name="">
				<arg>arggetval 1 reg1</arg>
			</instruction>
			<!-- ** reg2 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<!-- load the result in the register if known -->
			<instruction name="load">
				<arg>reg2</arg>
				<arg>reg1</arg>
			</instruction>
			<!-- ** reg1 = name of the register where the result is stored ** -->
			<instruction name="">
				<arg>varset reg1 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="expr_divide" nbargs="3" return="1">
			<!-- RULE = exprelt1 -->
			<!-- evaluate an expression DIVIDE -->
			
			<!-- ARG 1  :  right side of DIVIDE		-->
			<!-- ARG 2  :  left side of DIVIDE 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from DIVIDE expression ** -->
			<instruction name="idiv">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_expression" nbargs="3" return="1">
			<!-- RULE = expression, eval1, eval2, expr3 -->
			<!-- evaluation of an expression -->
			
			<!-- ARG 1  : left side of the expression 	-->
			<!-- ARG 2*  : right side of the expression  -->
			<!-- ARG 3?  : register to store the value  -->
			<!-- RETURN : register storing the result 	-->
					
			<!-- ** var1 = register to store (if unknown, new one) ** -->
			<instruction name="">
				<arg>argdefault 3 var1</arg>
			</instruction>
			<!-- ** reg1 = evaluated expression ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argeval1 1 reg1 var1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- next expressions -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<!-- if last, it will be stored in the known reg -->
			<instruction name="">
				<arg>iflast 2</arg>
			</instruction>
			<!-- ** reg2 = evaluated expression ** -->
			<instruction name="">
				<arg>argeval2 2 reg1 reg1 var1</arg>
			</instruction>
			<!-- else, it will be stored in a new reg -->
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argeval2 2 reg1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="expr_float" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get a float expression	-->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="iload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="expr_hexa" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get an hexa expression	-->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="iload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="expr_integer" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get an integer expression -->
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="iload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="expr_loff" nbargs="3" return="1">
			<!-- RULE = exprelt3 -->
			<!-- evaluate an expression LOFF -->
			
			<!-- ARG 1  :  right side of LOFF		-->
			<!-- ARG 2  :  left side of LOFF 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from LOFF expression ** -->
			<instruction name="ishl">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_modulo" nbargs="3" return="1">
			<!-- RULE = exprelt3 -->
			<!-- evaluate an expression MODULO -->
			
			<!-- ARG 1  :  right side of MODULO		-->
			<!-- ARG 2  :  left side of MODULO 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from MODULO expression ** -->
			<instruction name="irem">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_minus" nbargs="3" return="1">
			<!-- RULE = exprelt -->
			<!-- evaluate an expression MINUS -->
			
			<!-- ARG 1  :  right side of MINUS		-->
			<!-- ARG 2  :  left side of MINUS 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from MINUS expression ** -->
			<instruction name="isub">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
		<function name="expr_mult" nbargs="3" return="1">
			<!-- RULE = exprelt1 -->
			<!-- evaluate an expression MULT -->
			
			<!-- ARG 1  :  right side of MULT		-->
			<!-- ARG 2  :  left side of MULT 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from MULT expression ** -->
			<instruction name="imul">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>

		<function name="expr_negval" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- negate an expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- negate the expression -->
			<instruction name="ineg">
				<arg>reg2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>

		<function name="expr_paren" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- evaluate an expression in argenthesis -->
			
			<!-- ARG 1  : expression to evaluate 		-->
			<!-- RETURN : register storing the result  	-->	
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="expr_plus" nbargs="3" return="1">
			<!-- RULE = exprelt -->
			<!-- evaluate an expression PLUS -->
			
			<!-- ARG 1  :  right side of PLUS		-->
			<!-- ARG 2  :  left side of PLUS 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from PLUS expression ** -->
			<instruction name="iadd">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>

		<function name="expr_posval" nbargs="3" return="1">
			<!-- RULE = expr4 -->
			<!-- get a positive expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg2 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = evaluate the expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1 reg2</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="expr_roff" nbargs="3" return="1">
			<!-- RULE = exprelt3 -->
			<!-- evaluate an expression ROFF		-->
			
			<!-- ARG 1  :  right side of ROFF		-->
			<!-- ARG 2  :  left side of ROFF 		-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = expression's evaluation ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** reg1 = register where to store (if known) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = result from ROFF expression ** -->
			<instruction name="ishr">
				<arg>reg2</arg>
				<arg>2</arg>
				<arg>reg1</arg>
			</instruction>
			<return>reg2</return>
		</function>

		<function name="expr_string" nbargs="3" return="1">
			<!-- RULE = expression -->
			<!-- get string expression -->
			
			<!-- ARG 1  :  expression				-->
			<!-- ARG 3? :  register to store result -->
			<!-- RETURN :  register of expression	-->
			
			<!-- ** reg1 = register if known (new one else) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- load the value to the register -->
			<instruction name="baload">
				<arg>reg1</arg>
				<arg>1</arg>
			</instruction>
			<return>reg1</return>
		</function>
		
		<function name="stmt_affdec" nbargs="1" return="0">
			<!-- RULE = affstmt	-->
			<!-- affectation/declaration statement -->
			<!-- ARG 1  : aff statement to call 		-->

			<!-- ## call : stmt_declare ## -->
			<instruction name="">
				<arg>argcall 1 L N</arg>
			</instruction>
		</function>
		
		<function name="stmt_affect" nbargs="2" return="0">
			<!-- RULE = affstmt	-->
			<!-- store a value in a variable -->
			
			<!-- ARG 1 :  designator to store the value	-->
			<!-- ARG 2 :  expression to evaluate 		-->
			
			<!-- ** reg1 = evaluated expression ** -->
			<instruction name="">
				<arg>argeval1 2 reg1</arg>
			</instruction>
			<!-- ## appel : stmt_design (affectation for designator) ## -->
			<instruction name="">
				<arg>argcall 1 reg1</arg>
			</instruction>
		</function>

		<function name="stmt_argdim" nbargs="5" return="0">
			<!-- RULE = desdim	-->
			<!-- list of index in the array -->
			
			<!-- ARG 1  :  expr first index				-->
			<!-- ARG 2  :  other index' list			-->
			<!-- ARG 3  :  array's name	 				-->
			<!-- ARG 4  :  expression to affect			-->
			<!-- ARG 5? :  structure's field (if struct)-->

			
			<!-- ** var1 = number of arguments ** -->
			<instruction name="">
				<arg>argcpt 2 var1</arg>        
			</instruction>
			<instruction name="">
				<arg>varinc var1</arg>        	
			</instruction>

			<!-- if variable is a field, copy its value in a reg -->
			<instruction name="">
				<arg>ifstatic 3</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>getidstatic var5 3</arg>
			</instruction>
			<instruction name="getstatic">
				<arg>reg1</arg>
				<arg>var5</arg>
			</instruction>
			<!-- else, we get the variable's register -->
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>getidvar reg1 3</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg3 : first index evaluation ** -->
			<instruction name="">				
				<arg>argeval1 1 reg3</arg>			
			</instruction>
			<!-- ** reg4 : register of the expression to affect ** -->
			<instruction name="">				
				<arg>argdefault 4 reg4</arg>			
			</instruction>
			<!-- ** var3 = 1 (value) ** -->
			<instruction name="">
				<arg>varinit var3 1</arg>        
			</instruction>
			
			<!-- ********************* -->
			<!-- unidimensional arrays -->
			<!-- ********************* -->
	
			<!-- if one dimension AND structure, get the value -->
			<instruction name="">
				<arg>ifexists 5</arg>        
			</instruction>
			<instruction name="">
				<arg>ifequal var1 var3</arg>        
			</instruction>
			<!-- get the object -->
			<instruction name="">
				<arg>codetmpreg reg2</arg>        
			</instruction>
			<instruction name="getarray">				
				<arg>reg2</arg>					
				<arg>reg1</arg>
				<arg>reg3</arg>
			</instruction>
			<instruction name="setfield">				
				<arg>reg2</arg>					
				<arg>reg4</arg>
				<arg>5</arg>
			</instruction>
			<instruction name="">
				<arg>varset reg4 reg2</arg>        
			</instruction>
			<instruction name="">
				<arg>endif</arg>        
			</instruction>
			<!-- set the value in the array -->
			<instruction name="">
				<arg>ifequal var1 var3</arg>        
			</instruction>
			<instruction name="setarray">				
				<arg>reg1</arg>					
				<arg>reg4</arg>
				<arg>reg3</arg>
			</instruction>
			<instruction name="">
				<arg>exit</arg>        
			</instruction>
			<instruction name="">
				<arg>endif</arg>        
			</instruction>
			

			<!-- *********************** -->
			<!-- multidimensional arrays -->
			<!-- *********************** -->
			
			<!-- ** reg2 : index' array ** -->
			<instruction name="">				
				<arg>codetmpreg reg2</arg>		
			</instruction>
			<instruction name="newarray">				
				<arg>reg2</arg>					
				<arg>var1</arg>
			</instruction>
			<!-- ** cpt1 : parameters' counter ** -->
			<instruction name="">				
				<arg>varinit cpt1 0</arg>		
			</instruction>
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<!-- same for the other index -->
			<instruction name="">
				<arg>loop 2</arg>				
			</instruction>
			<instruction name="">				
				<arg>varinc cpt1</arg>			
			</instruction>
			<!-- ## reg3 = elt_argdim ## -->
			<instruction name="">				
				<arg>arggetval 2 reg3</arg>		
			</instruction>
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<!-- end loop other index -->
			<instruction name="">
				<arg>endloop</arg>				
			</instruction>
			<!-- registers for the functions' arguments -->
			<instruction name="">
				<arg>varinit reg-2 r-2</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg-1 r-1</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg-0 r-0</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg+1 r+1</arg>	
			</instruction>
			
			<instruction name="">				
				<arg>ifexists 5</arg>			
			</instruction>
			<!-- starting parameters -->
			<instruction name="nop"/>
			<!-- arg1 => number of parameters -->
			<instruction name="iload">
				<arg>reg-1</arg>						
				<arg>var1</arg>
			</instruction>
			<!-- arg2 => index' list -->
			<instruction name="load">
				<arg>reg-0</arg>							
				<arg>reg2</arg>
			</instruction>
			<!-- call code getelem -->
			<instruction name="">				
				<arg>varinit var2 str_dim.getelt</arg>	
			</instruction>
			<instruction name="call">
				<arg>var2</arg>
				<arg>reg1</arg>
			</instruction>
			<!-- get the returned value -->
			<instruction name="">				
				<arg>codetmpreg reg4</arg>			
			</instruction>
			<instruction name="load">				
				<arg>reg4</arg>
				<arg>reg+1</arg>			
			</instruction>
			<!-- set the structure's field -->
			<instruction name="setfield">				
				<arg>reg4</arg>
				<arg>4</arg>
				<arg>5</arg>
			</instruction>
			<instruction name="">				
				<arg>else</arg>			
			</instruction>
			<!-- ** reg4 = expression to set ** -->
			<instruction name="">				
				<arg>argdefault 4 reg4</arg>			
			</instruction>
			<instruction name="">				
				<arg>endif</arg>			
			</instruction>
			<!-- starting parameters -->
			<instruction name="nop"/>
			<!-- arg1 => number of parameters -->
			<instruction name="iload">
				<arg>reg-2</arg>						
				<arg>var1</arg>
			</instruction>
			<!-- arg2 => index list -->
			<instruction name="load">
				<arg>reg-1</arg>							
				<arg>reg2</arg>
			</instruction>
			<!-- arg3 => value to affect -->
			<instruction name="load">
				<arg>reg-0</arg>							
				<arg>reg4</arg>
			</instruction>
			<!-- call the code getelem -->
			<instruction name="">				
				<arg>varinit var2 str_dim.setelt</arg>	
			</instruction>
			<instruction name="call">
				<arg>var2</arg>
				<arg>reg1</arg>
			</instruction>
		</function>

		<function name="stmt_argument" nbargs="3" return="1">
			<!-- RULE = argstmt	-->
			<!-- function to set the arguments for a function call	-->
			
			<!-- ARG 1  : first argument's expression	-->
			<!-- ARG 2  : next arguments  				-->
			<!-- ARG 3  : function's name			   	-->
			<!-- RETURN : number of arguments   		-->	
			
			<!-- ** var1 = number of arguments ** -->
			<instruction name="">
				<arg>argcpt 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>varinc var1</arg>
			</instruction>
			<!-- ** cpt1 = counter of arguments ** -->
			<instruction name="">
				<arg>varinit cpt1 1</arg>
			</instruction>
			<!-- ** reg2 = register for the first argument ** -->
			<instruction name="">
				<arg>vargetreg reg2 cpt1 var1</arg>
			</instruction>
			<!-- ** reg3 = register containing the first argument ** -->
			<instruction name="">
				<arg>argeval1 1 reg3 reg2</arg>
			</instruction>
			<!-- if reg2 != reg3, load reg3 in reg2 -->
			<instruction name="">
				<arg>ifequal reg2 reg3</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="load">
				<arg>reg2</arg>
				<arg>reg3</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- same routine for the next arguments -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>varinc cpt1</arg>
			</instruction>
			<instruction name="">
				<arg>vargetreg reg2 cpt1 var1</arg>
			</instruction>
			<!-- ## call : elt_argument ## -->
			<instruction name="">
				<arg>argcall 2 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- ** var1 = number of arguments ** -->
			<return>var1</return>
		</function>

		<function name="stmt_break" nbargs="0" return="0">
			<!-- RULE = brkstmt	-->
			<!-- execute a break (quit the current structure)	-->

			<!-- ** lbl1 = label at the end of the structure ** -->
			<instruction name="">
				<arg>strgetlbl lbl1 END</arg>
			</instruction>
			<!-- goto this label -->
			<instruction name="goto">
				<arg>lbl1</arg>
			</instruction>
		</function>
		
		<function name="stmt_call" nbargs="2" return="1">
			<!-- RULE = callstmt -->
			<!-- statement to call a function -->
			
			<!-- ARG 1  : function to call 		-->
			<!-- ARG 2  : arguments list	  	-->
			
			<!-- ** delimit the beginning of arguments ** -->
			<instruction name="nop"/>
			<!-- ** var1 = number of arguments ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- ## var1 = stmt_argument ## -->
			<instruction name="">
				<arg>arggetval 2 var1 1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 0</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- set the max number for arguments in this code -->
			<instruction name="">
				<arg>codeparmax var1</arg>
			</instruction>
			<!-- ** inst1 = instruction to call (call or native) ** -->
			<instruction name="">
				<arg>fcttype 1 inst1 var2</arg>
			</instruction>
			<instruction name="custom">
				<arg>inst1</arg>
				<arg>var2</arg>
			</instruction>
		</function>
		
		<function name="stmt_case" nbargs="4" return="0">
			<!-- RULE = casestmt -->
			<!-- statement elseif (of a if structure)	-->
			
			<!-- ARG 1  : expression to compare			-->
			<!-- ARG 2+ : statements of the block		-->
			<!-- ARG 3 : expression to evaluate 		-->
			<!-- ARG 4 : label end of the structure		-->
			
			<!-- ** reg1 = evaluation of the expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** lbl1 = label after the case block ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 CASE_end</arg>
			</instruction>
			<!-- if !condition, goto end block -->
			<instruction name="ifcmpne">
				<arg>3</arg>
				<arg>reg1</arg>
				<arg>lbl1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- goto the end of the if structure -->
			<instruction name="goto">
				<arg>4</arg>
			</instruction>
			<!-- label for the end of the block -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
		</function>
		
		<function name="stmt_continue" nbargs="0" return="0">
			<!-- RULE = ctnstmt -->
			<!-- execute a continue (skip to next iteration) -->
			
			<!-- ** lbl1 = label before the iteration ** -->
			<instruction name="">
				<arg>strgetlbl lbl1 ITE</arg>
			</instruction>
			<!-- goto this label -->
			<instruction name="goto">
				<arg>lbl1</arg>
			</instruction>
		</function>
		
		<function name="stmt_declare" nbargs="5" return="0">
			<!-- RULE = decstmt -->
			<!-- Function to declare and/or affect a variable -->
			
			<!-- ARG 1  :  name of the variable		-->
			<!-- ARG 2? :  type of the variable		-->
			<!-- ARG 3?  :  expression to affect  	-->
			<!-- ARG 4  :  static or local 			-->
			<!-- ARG 5  :  const or not  			-->
			
			<!-- ** reg1 = type of the variable (int by default) ** -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- COMPILE : variable already exists -->
			<instruction name="">
				<arg>redefvar 1</arg>
			</instruction>
			<!-- ## var1 = elt_typedef ## -->
			<instruction name="">
				<arg>arggetval 2 var1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 int</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg2 = variable's register (if local and if exists) ** -->
			<instruction name="">
				<arg>iflocal 1</arg>
			</instruction>
			<instruction name="">
				<arg>getidvar reg2 1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>varinit reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- ** reg1 = evaluated expression (if it exists) ** -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<!-- ## reg1 = elt_affect ## -->
			<instruction name="">
				<arg>arggetval 3 reg1 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<!-- create a variable without the register -->
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- if register already used by another variable, create a new one -->
			<instruction name="">
				<arg>ifused reg1</arg>
			</instruction>
			<instruction name="">
				<arg>ifnequal reg1 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="load">
				<arg>reg2</arg>
				<arg>reg1</arg>
			</instruction>
			<instruction name="">
				<arg>varset reg1 reg2</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- create a variable if it doesn't exist, or only affect it -->
			<instruction name="">
				<arg>setvar var3 1 var1 4 5 reg1</arg>
			</instruction>
			
			<!-- if the type is a structure, create a new object -->
			<instruction name="">
				<arg>ifstruct var1</arg>
			</instruction>
			<instruction name="new">
				<arg>reg1</arg>
				<arg>var1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>

			<!-- if it's a constant and already exists, it can't be affected -->
			<instruction name="">
				<arg>ifequal var3 N</arg>
			</instruction>
			<instruction name="">
				<arg>isconst 1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- if it's a global var, it has to be affected -->
			<instruction name="">
				<arg>ifstatic 1</arg>
			</instruction>
			<instruction name="">
				<arg>getidstatic var4 1</arg>
			</instruction>
			<instruction name="setstatic">
				<arg>reg1</arg>
				<arg>var4</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
		</function>
	
		<function name="stmt_default" nbargs="1" return="0">
			<!-- RULE = defstmt -->
			<!-- default statement (in a select structure) -->
			
			<!-- ARG 1+  : statements to execute	-->
			
			<instruction name="">
				<arg>loop 1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>argcall 1</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
		</function>
		
		<function name="stmt_design" nbargs="4" return="0">
			<!-- RULE = designator -->
			<!-- RULE = designator to be affected -->
			
			<!-- ARG 1 :  variable's name				-->
			<!-- ARG 2 :  array part (if array)			-->
			<!-- ARG 3 :  structure part (if struct)	-->
			<!-- ARG 4 :  register to store expression	-->
			
			<!-- if the variable is a structure -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<!-- COMPILE : check the structure -->
			<instruction name="">
				<arg>isstruct 1</arg>
			</instruction>
			<!-- ## var1 = stmt_strelt ## -->
			<instruction name="">
				<arg>arggetval 3 var1 1</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>argdefault 3 var1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- if the variable is an object array -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- COMPILE : check if array -->
			<instruction name="">
				<arg>isarray 1</arg>
			</instruction>
			<!-- ## call : stmt_argdim ## -->
			<instruction name="">
				<arg>argcall 2 1 4 var1</arg>
			</instruction>	
			<instruction name="">
				<arg>exit</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- simple structure (not an array) -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>getidvar reg1 1</arg>
			</instruction>
			<instruction name="setfield">
				<arg>reg1</arg>
				<arg>4</arg>
				<arg>var1</arg>
			</instruction>
			<!-- simple variable (not struct nor array) -->
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<!-- COMPILE : check if variable -->
			<instruction name="">
				<arg>isvariable 1</arg>
			</instruction>
			<instruction name="">
				<arg>getidvar reg1 1</arg>
			</instruction>
			<!-- check if non constant(break elsewhere) -->
			<instruction name="">
				<arg>isconst 1</arg>
			</instruction>
			<instruction name="load">
				<arg>reg1</arg>
				<arg>4</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
		</function>
		
		<function name="stmt_elseif" nbargs="3" return="0">
			<!-- RULE = elifstmt -->
			<!-- statement elseif (of a if structure) -->
			
			<!-- ARG 1  : condition						-->
			<!-- ARG 2+ : statements to execute			-->
			<!-- ARG 3 : label end of if structure 		-->
			
			<!-- evaluate the main condition -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** lbl1 = label after the block ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 IF_elsif</arg>
			</instruction>
			<!-- if !condition, goto end block -->
			<instruction name="ifeg">
				<arg>reg1</arg>
				<arg>lbl1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- goto the end of the if structure -->
			<instruction name="goto">
				<arg>3</arg>
			</instruction>
			<!-- label for the end of the block -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
		</function>
		
		<function name="stmt_else" nbargs="1" return="0">
			<!-- RULE = elsestmt -->
			<!-- else statement (in an if structure) -->
			
			<!-- ARG 1+  : statements to execute	 -->

			<instruction name="">
				<arg>loop 1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>argcall 1</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
		</function>

		<function name="stmt_end" nbargs="0" return="0">
			<!-- RULE = endstmt -->
			<!-- quit the current function -->
			
			<instruction name="return"/>
		</function>

		<function name="stmt_for" nbargs="5" return="0">
			<!-- RULE = forstmt -->
			<!-- for statement (number of iterations) -->
			
			<!-- ARG 1  : counter variable				 -->
			<!-- ARG 2  : first value for the variable	 -->
			<!-- ARG 3  : last value for the variable	 -->
			<!-- ARG 4? : step between variable's values -->
			<!-- ARG 5+ : statements to execute			 -->

			<!-- ** lbl1 = label of the loop's beginning ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 FOR_cond</arg>
			</instruction>
			<!-- ** lbl2 = label of the loop's end ** -->
			<instruction name="">
				<arg>strnewlbl lbl2 FOR_end</arg>
			</instruction>
			<!-- ** lbl3 = label before the increment ** -->
			<instruction name="">
				<arg>strnewlbl lbl3 FOR_ite</arg>
			</instruction>
			
			<!-- ## reg1 = elt_forvar ## -->
			<instruction name="">
				<arg>arggetval 1 reg1</arg>
			</instruction>
			<!-- ** reg2 = evaluate beginning expression ** -->
			<instruction name="">
				<arg>argeval1 2 reg2 reg1</arg>
			</instruction>
			<!-- ** reg3 = evaluate end expression ** -->
			<instruction name="">
				<arg>argeval1 3 reg3</arg>
			</instruction>
			<!-- ** reg4 = step between values ** -->
			<instruction name="">
				<arg>ifexists 4</arg>
			</instruction>
			
			<!-- ## reg4 = stmt_step ## -->
			<instruction name="">
				<arg>arggetval 4 reg4</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<!-- by default step = 1 -->
			<instruction name="">
				<arg>codetmpreg reg4</arg>
			</instruction>
			<instruction name="">
				<arg>varinit var1 1</arg>
			</instruction>
			<instruction name="iload">
				<arg>reg4</arg>
				<arg>var1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- open the structure (for break and continue stmt) -->
			<instruction name="">
				<arg>stropen lbl1 lbl3 lbl2</arg>
			</instruction>
			<!-- label at the beginning -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
			<!-- if variable > max, goto the end of the structure -->
			<instruction name="ifcmpgt">
				<arg>reg1</arg>
				<arg>reg3</arg>
				<arg>lbl2</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 5</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 5</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- label before the iteration -->
			<instruction name="label">
				<arg>lbl3</arg>
			</instruction>
			<instruction name="iadd">
				<arg>reg1</arg>
				<arg>reg1</arg>
				<arg>reg4</arg>
			</instruction>
			<!-- back to the beginning -->
			<instruction name="goto">
				<arg>lbl1</arg>
			</instruction>
			<!-- label end of the loop -->
			<instruction name="label">
				<arg>lbl2</arg>
			</instruction>
			<!-- close the current structure -->
			<instruction name="">
				<arg>strclose</arg>
			</instruction>
		</function>

		<function name="stmt_goto" nbargs="1" return="0">
			<!-- RULE = gotostmt -->
			<!-- goto the label	-->
			<!-- ARG 1  : label -->
			
			<instruction name="goto">
				<arg>1</arg>
			</instruction>
			<instruction name="">
				<arg>codegoto 1</arg>
			</instruction>
		</function>

		<function name="stmt_if" nbargs="4" return="0">
			<!-- RULE = ifstmt -->
			<!-- if statement (conditional treatment) -->
			
			<!-- ARG 1  : main condition		-->
			<!-- ARG 2+ : statements to execute	-->
			<!-- ARG 3* : elseif conditions 	-->
			<!-- ARG 4? : else conditions 		-->

			<!-- evaluate the main condition -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** lbl1 = label after the first block ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 IF_cond</arg>
			</instruction>
			<!-- ** lbl2 = label after the last block ** -->
			<instruction name="">
				<arg>strnewlbl lbl2 IF_end</arg>
			</instruction>
			<!-- if !condition, goto end first block -->
			<instruction name="ifeg">
				<arg>reg1</arg>
				<arg>lbl1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- goto the end of the if structure -->
			<instruction name="goto">
				<arg>lbl2</arg>
			</instruction>
			<!-- label after first block -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
			<!-- ## call : stmt_elseif ## -->
			<instruction name="">
				<arg>loop 3</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 3 lbl2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- ## call : stmt_else ## -->
			<instruction name="">
				<arg>ifexists 4</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 4</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- label for the end of if structure -->
			<instruction name="label">
				<arg>lbl2</arg>
			</instruction>
		</function>

		<function name="stmt_label" nbargs="1" return="0">
			<!-- RULE = lbldef -->
			<!-- create a label -->
			<!-- ARG 1  : label's name	-->
			
			<instruction name="label">
				<arg>1</arg>
			</instruction>
			<!-- add a label -->
			<instruction name="">
				<arg>newlabel 1</arg>
			</instruction>
		</function>

		<function name="stmt_procret" nbargs="1" return="0">
			<!-- RULE = prtstmt -->
			<!-- return a value (end the code)	-->
			<!-- ARG 1  : expression to send	-->
			
			<!-- ** reg1 = evaluated expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<instruction name="ireturn">
				<arg>reg1</arg>
			</instruction>
		</function>

		<function name="stmt_repeat" nbargs="2" return="0">
			<!-- RULE = repstmt -->
			<!-- repeat statement (conditional loop) -->
			
			<!-- ARG 1  : statements to execute	-->
			<!-- ARG 2+ : iteration condition	-->
			
			<!-- ** lbl1 = label of the loop's beginning ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 RPT_cond</arg>
			</instruction>
			<!-- ** lbl2 = label of the loop's end ** -->
			<instruction name="">
				<arg>strnewlbl lbl2 RPT_end</arg>
			</instruction>
			<!-- ** lbl3 = label before the increment ** -->
			<instruction name="">
				<arg>strnewlbl lbl3 RPT_ite</arg>
			</instruction>
			<!-- open the structure (for break and continue stmt) -->
			<instruction name="">
				<arg>stropen lbl1 lbl3 lbl2</arg>
			</instruction>
			<!-- label at the beginning -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 1</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 1</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- label before the iteration -->
			<instruction name="label">
				<arg>lbl3</arg>
			</instruction>
			<!-- ** reg1 = evaluation of the condition ** -->
			<instruction name="">
				<arg>argeval1 2 reg1</arg>
			</instruction>
			<!-- if !condition, goto beginning of the loop -->
			<instruction name="ifeg">
				<arg>reg1</arg>
				<arg>lbl1</arg>
			</instruction>
			<!-- label at the end -->
			<instruction name="label">
				<arg>lbl2</arg>
			</instruction>
			<!-- close the current structure -->
			<instruction name="">
				<arg>strclose</arg>
			</instruction>
		</function>

		<function name="stmt_select" nbargs="3" return="0">
			<!-- RULE = selstmt -->
			<!-- select statement (evaluation of an expression) -->
			
			<!-- ARG 1  : expression to evaluate	-->
			<!-- ARG 2* : cases blocks				-->
			<!-- ARG 3? : default block			 	-->
			
			<!-- ** reg1 = evaluation of the expression ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- ** lbl1 = label of the select end ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 SEL_end</arg>
			</instruction>
			<!-- ## call : stmt_case ## -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 2 reg1 lbl1</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- ## call : stmt_default ## -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 3</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- label for the end of select structure -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
		</function>

		<function name="stmt_stmt" nbargs="1" return="0">
			<!-- RULE = affstmt, stmt, stmtseq -->
			<!-- execute the child function	-->
			<!-- ARG 1  : child function	-->
			
			<!-- ## call : the statement ## -->
			<instruction name="">
				<arg>argcall 1</arg>
			</instruction>
		</function>

		<function name="stmt_step" nbargs="1" return="0">
			<!-- RULE = stpstmt -->
			<!-- step between values (for structure)	-->
			<!-- ARG 1  : step value 			-->
			<!-- RETURN : evaluated expression 	-->
			
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<return>reg1</return>
		</function>

		<function name="stmt_strelt" nbargs="2" return="1">
			<!-- RULE = desstr -->
			<!-- get a field's structure id -->
			
			<!-- ARG 1 :  structure's field to get 	-->
			<!-- ARG 2 :  name of the variable		-->
			<instruction name="">
				<arg>getvartype var1 2</arg>
			</instruction>
			<!-- COMPILE :  check the field	-->
			<instruction name="">
				<arg>isstrfield 1 var1</arg>
			</instruction>
			<instruction name="">
				<arg>varconcat var2 var1 .</arg>
			</instruction>
			<instruction name="">
				<arg>varconcat var2 var2 1</arg>
			</instruction>
			<return>var2</return>
		</function>
		
		<function name="stmt_while" nbargs="2" return="0">
			<!-- RULE = whlstmt -->
			<!-- while statement (conditional loop)	-->
			
			<!-- ARG 1  : main condition		-->
			<!-- ARG 2+ : statements to execute	-->
			
			<!-- ** lbl1 = label of the loop's beginning ** -->
			<instruction name="">
				<arg>strnewlbl lbl1 WHI_cond</arg>
			</instruction>
			<!-- ** lbl2 = label of the loop's end ** -->
			<instruction name="">
				<arg>strnewlbl lbl2 WHI_end</arg>
			</instruction>
			<!-- open the structure (for break and continue stmt) -->
			<instruction name="">
				<arg>stropen lbl1 lbl1 lbl2</arg>
			</instruction>
			<!-- label at the beginning -->
			<instruction name="label">
				<arg>lbl1</arg>
			</instruction>
			<!-- ** reg1 = evaluation of the condition ** -->
			<instruction name="">
				<arg>argeval1 1 reg1</arg>
			</instruction>
			<!-- if !condition, goto end of the loop -->
			<instruction name="ifeg">
				<arg>reg1</arg>
				<arg>lbl2</arg>
			</instruction>
			<!-- ## call : stmt ## -->
			<instruction name="">
				<arg>loop 2</arg>
			</instruction>
			<instruction name="">
				<arg>argcall 2</arg>
			</instruction>
			<instruction name="">
				<arg>endloop</arg>
			</instruction>
			<!-- return to the beginning of the loop -->
			<instruction name="goto">
				<arg>lbl1</arg>
			</instruction>
			<!-- label at the end -->
			<instruction name="label">
				<arg>lbl2</arg>
			</instruction>
			<!-- close the current structure -->
			<instruction name="">
				<arg>strclose</arg>
			</instruction>
		</function>

		<function name="val_argdim" nbargs="3" return="1">
			<!-- RULE = desdimval -->
			<!-- arguments for the array -->
			
			<!-- ARG 1 :  expr first index		-->
			<!-- ARG 2 :  list of other index	-->
			<!-- ARG 3 :  array's register		-->
			
			<!-- ** reg3 : evaluate the first index ** -->
			<instruction name="">				
				<arg>argeval1 1 reg3</arg>			
			</instruction>
	
			<!-- ********************* -->
			<!-- unidimensional arrays -->
			<!-- ********************* -->

			<instruction name="">
				<arg>ifexists 2</arg>        
			</instruction>
			<instruction name="">
				<arg>else</arg>        
			</instruction>
			<instruction name="">				
				<arg>codetmpreg reg4</arg>		
			</instruction>
			<instruction name="getarray">				
				<arg>reg4</arg>
				<arg>3</arg>				
				<arg>reg3</arg>
			</instruction>
			<instruction name="">
				<arg>exit</arg>        
			</instruction>
			<instruction name="">
				<arg>endif</arg>        
			</instruction>
			
			<!-- *********************** -->
			<!-- multidimensional arrays -->
			<!-- *********************** -->
			
			<!-- ** var1 = number of arguments ** -->
			<instruction name="">
				<arg>argcpt 2 var1</arg>        
			</instruction>
			<instruction name="">
				<arg>varinc var1</arg>        	
			</instruction>
			<!-- ** reg2 : index' array ** -->
			<instruction name="">				
				<arg>codetmpreg reg2</arg>		
			</instruction>
			<instruction name="newarray">				
				<arg>reg2</arg>					
				<arg>var1</arg>
			</instruction>
			<!-- ** cpt1 : parameters' counter ** -->
			<instruction name="">				
				<arg>varinit cpt1 0</arg>		
			</instruction>
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<!-- same for the other index -->
			<instruction name="">
				<arg>loop 2</arg>				
			</instruction>
			<instruction name="">				
				<arg>varinc cpt1</arg>			
			</instruction>
			<!-- ## reg3 = val_argdim ## -->
			<instruction name="">				
				<arg>arggetval 2 reg3</arg>		
			</instruction>
			<instruction name="setarray">				
				<arg>reg2</arg>					
				<arg>reg3</arg>
				<arg>cpt1</arg>
			</instruction>
			<!-- end loop other index -->
			<instruction name="">
				<arg>endloop</arg>				
			</instruction>
			<!-- starting parameters -->
			<instruction name="nop"/>
			<!-- registers for the codes' arguments -->
			<instruction name="">
				<arg>varinit reg-1 r-1</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg-0 r-0</arg>	
			</instruction>
			<instruction name="">
				<arg>varinit reg+1 r+1</arg>	
			</instruction>
			<!-- arg1 => number of parameters -->
			<instruction name="iload">
				<arg>reg-1</arg>						
				<arg>var1</arg>
			</instruction>
			<!-- arg2 => index' list -->
			<instruction name="load">
				<arg>reg-0</arg>							
				<arg>reg2</arg>
			</instruction>
			<!-- call the code getelem -->
			<instruction name="">				
				<arg>varinit var2 str_dim.getelt</arg>	
			</instruction>
			<instruction name="call">
				<arg>var2</arg>
				<arg>3</arg>
			</instruction>
			<!-- get the returned value -->
			<instruction name="">				
				<arg>codetmpreg reg4</arg>			
			</instruction>
			<instruction name="load">				
				<arg>reg4</arg>
				<arg>reg+1</arg>			
			</instruction>
			<return>reg4</return>
		</function>
		
		<function name="val_design" nbargs="3" return="1">
			<!-- RULE = designval -->
			<!-- get designator's value -->
			
			<!-- ARG 1  :  name of the variable			-->
			<!-- ARG 2  :  array's block (if array)		-->
			<!-- ARG 3  :  structure's block (if struct)-->
			<!-- RETURN :  register storing the value  	-->
			
			
			<!-- if variable is a field, copy its value in a reg -->
			<instruction name="">
				<arg>ifstatic 1</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg1</arg>
			</instruction>
			<instruction name="">
				<arg>getidstatic var1 1</arg>
			</instruction>
			<instruction name="getstatic">
				<arg>reg1</arg>
				<arg>var1</arg>
			</instruction>
			<!-- else, we get the variable's register -->
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<instruction name="">
				<arg>getidvar reg1 1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>

			<!-- if the variable is an array -->
			<instruction name="">
				<arg>ifexists 2</arg>
			</instruction>
			<!-- COMPILE : check if array -->
			<instruction name="">
				<arg>isarray 1</arg>
			</instruction>
			<!-- ## reg1 = val_argdim ## -->
			<instruction name="">
				<arg>arggetval 2 reg1 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<!-- if the variable is a structure -->
			<instruction name="">
				<arg>ifexists 3</arg>
			</instruction>
			<!-- COMPILE : check the structure -->
			<instruction name="">
				<arg>isstruct 1</arg>
			</instruction>
			<!-- ## var3 = stmt_strelt ## -->
			<instruction name="">
				<arg>arggetval 3 var3 1</arg>
			</instruction>
			<instruction name="">
				<arg>codetmpreg reg2</arg>
			</instruction>
			<instruction name="getfield">
				<arg>reg2</arg>
				<arg>reg1</arg>
				<arg>var3</arg>
			</instruction>
			<instruction name="">
				<arg>else</arg>
			</instruction>
			<!-- COMPILE : check if variable -->
			<instruction name="">
				<arg>isvariable 1</arg>
			</instruction>
			<instruction name="">
				<arg>varset reg2 reg1</arg>
			</instruction>
			<instruction name="">
				<arg>endif</arg>
			</instruction>
			<return>reg2</return>
		</function>
		
	</compile>

	<!-- Native functions -->
	<natives>
		<!-- pob-robotics-suite native functions -->
		<prs file="lib_prs.bas">
			<function name="MoveStop" internal="pobMoveStop" nbargs="0" return=""/>
			<function name="MoveForward" internal="pobMoveForward" nbargs="0" return=""/>
			<function name="MoveLeft" internal="pobMoveLeft" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="MoveRight" internal="pobMoveRight" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="MoveBackward" internal="pobMoveBackward" nbargs="0" return="" >
			</function>
			<function name="SetServo" internal="pobActuatorServo" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="Wait" internal="pobSystemWait" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			
			<function name="WaitUs" internal="pobSystemWaitUs" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			
			<function name="GetAnalog" internal="pobSensorGetAnalog" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			<function name="GetDigitalInput" internal="pobSensorGetDigitalInput" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			<function name="SetDigitalOutput" internal="pobSensorSetDigitalOutput" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="WaitButtonPress" internal="pobUiWaitButton" nbargs="0" return="" >
			</function>
			<function name="PrintVariable" internal="pobUiPrintVariable" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="PrintText" internal="pobUiPrintText" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			
			<function name="InitUart0" internal="pobCommUart0Init" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="SendByteUart0" internal="pobCommUart0Send" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="ReceiveByteUart0" internal="pobCommUart0Rcv" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="InitUart1" internal="pobCommUart1Init" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="SendByteUart1" internal="pobCommUart1Send" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="ReceiveByteUart1" internal="pobCommUart1Rcv" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="SendBufferI2c0" internal="pobCommI2c0Send" nbargs="3" return="" >
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="ReceiveBufferI2c0" internal="pobCommI2c0Rcv" nbargs="3" return="" >
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<!--
			<function name="GetLight" internal="pobSensorLight" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			-->
			<function name="GetDistance" internal="pobSensorGp2d12Distance" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			<function name="GetBumper" internal="pobSensorGetDigitalInput" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			<function name="MoveToXY" internal="pobMoveGoToXY" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SetMotor" internal="pobMoveDcMotor" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<!--
			<function name="GetPosition" internal="pobMoveGetPositionStructure" nbargs="1" return="" >
				<arg>Position</arg>
			</function>
			-->
			
			<function name="GetLineFollower" internal="pobSensorLineFollowerStructure" nbargs="2" return="" >
				<arg>int</arg>
				<arg>LineFollower</arg>
			</function>
			
			<!--
			<function name="ResetPosition" internal="pobMoveResetPosition" nbargs="0" return="" />
			-->
			<function name="GetIrBeacon" internal="pobSensorIrFollower" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="SetLed" internal="pobUiSetLed" nbargs="1" return="" />

			<function name="GetButton" internal="pobUiGetButton" nbargs="" return="1" />
			
			<!--
			<function name="SwitchServo" internal="pobActuatorServoSwitch" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			-->
			
			<function name="TimerStart" internal="pobTimerStart" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			<function name="IsTimerOverflow" internal="pobTimerIsOverflow" nbargs="" return="1" />
			<function name="TimerStop" internal="pobTimerStop" nbargs="" return="" />
			
			<function name="ClockStart" internal="pobSensorChronoStart" nbargs="" return="" />
			<function name="ClockGet" internal="pobSensorChronoGet" nbargs="" return="1" />
			
			<function name="Random" internal="pobMathRandom" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<!--
			<function name="Cos" internal="pobMathCos" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="Sin" internal="pobMathSin" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			-->
			
			<function name="GetJoypad" internal="pobJoypadBasic" nbargs="1" return="" >
				<arg>Joypad</arg>
			</function>
			
		</prs>
		
		<!-- vex-cortex native functions -->
		<vex file="" >
			<function name="SetServo" internal="pobActuatorServo" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="Wait" internal="pobSystemWait" nbargs="1" return="" >
				<arg>int</arg>
			</function>

			<function name="GetAnalog" internal="pobSensorGetAnalog" nbargs="1" return="1" >
				<arg>int</arg>
			</function>

			<function name="GetDigitalInput" internal="pobSensorGetDigitalInput" nbargs="1" return="1" >
				<arg>int</arg>
			</function>

			<function name="SetDigitalOutput" internal="pobSensorSetDigitalOutput" nbargs="2" >
				<arg>int</arg>
				<arg>int</arg>
			</function>

			<function name="SetMotor" internal="vexActuatorMotor" nbargs="2" return="" >
				<arg>int</arg>
				<arg>int</arg>
			</function>

			<function name="StopMotor" internal="vexActuatorStopMotor" nbargs="1" return="" >
				<arg>int</arg>
			</function>

			<function name="GetBumperSwitch" internal="vexSensorBumperSwitch" nbargs="1" return="1" >
				<arg>int</arg>
			</function>

			<function name="GetLightSensor" internal="vexSensorLight" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="GetLimitSwitch" internal="vexSensorLimitSwitch" nbargs="1" return="1" >
				<arg>int</arg>
			</function>

			<function name="GetLineFollower" internal="vexSensorLineFollower" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="GetPotentiometer" internal="vexSensorPotentiometer" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="GetJoystickAnalog" internal="vexJoystickGetAnalog" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>

			<function name="GetJoystickButton" internal="vexJoystickGetButton" nbargs="3" return="1" >
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<!-- todo for basic: cos/sin/tan/... -->
			<function name="GetMath" internal="pobMathTrigonometric" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="GetUltrasonicSensor" internal="vexSensorGetUltrasonic" nbargs="2" return="1" >
				<arg>int</arg>
				<arg>int</arg>
			</function>
	
			<function name="GetOpticalEncoder" internal="vexSensorGetOpticalEncoder" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="ClockStart" internal="pobSensorChronoStart" nbargs="" return="" >
			</function>

			<function name="ClockGet" internal="pobSensorChronoGet" nbargs="1" return="1" >
				<arg>int</arg>
			</function>
			
			<function name="WaitMs" internal="pobSystemWaitMs" nbargs="1" return="" >
				<arg>int</arg>
			</function>
			
			<function name="PrintText" internal="pobUiPrintText" nbargs="3" return="" >
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
			<function name="PrintVariable" internal="pobUiPrintVariable" nbargs="3" return="" >
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			
		</vex>
		
		<!-- pobeye2 (POB-BOT II) native functions -->
		<pobeye2 file="lib_basic_pobbot2.bas">
			<function name="Acos" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="Asin" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="Atan" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="BinaryFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="ClearGraphic" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ClearPinPortA" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ClearPinPortC" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ClearPinPortD" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ClrAndSetOuput" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ClrOutput" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="ConfigPortA" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>	
			</function>
			<function name="ConfigPortAnalogic" internal ="gnap" nbargs="0" return=""/>
			<function name="ConfigPortC" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>	
			</function>
			<function name="ConfigPortD" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>	
			</function>
			<function name="Cos" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="DrawALine" internal ="gnap" nbargs="5" return="">
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="DrawAPoint" internal ="gnap" nbargs="3" return="">
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="DrawBMP" internal ="gnap" nbargs="4" return="">
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="DrawCameraFrame" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="GetBluePixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetBMPHeight" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetBMPWidth" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetGreenPixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetHuePixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetInput" internal ="gnap" nbargs="0" return="int"/>
			<function name="GetLightPixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetPinPortA" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetPinPortC" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetPinPortD" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetPortA" internal ="gnap" nbargs="0" return="int"/>
			<function name="GetPortAnalog" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetPortC" internal ="gnap" nbargs="0" return="int"/>
			<function name="GetPortD" internal ="gnap" nbargs="0" return="int"/>
			<function name="GetRedPixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GetSaturationPixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="GrabBlueFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrabGreenFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrabHSLFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrabRedFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrabRGBFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrayFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="GrayPixel" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="I2CSetSlaveAddress" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="I2CSpeed" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="I2CStop" internal ="gnap" nbargs="0" return="int"/>
			<function name="I2CRead" internal ="gnap" nbargs="0" return="int"/>
			<function name="I2CWrite" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="Identify" internal ="gnap" nbargs="1" return="int">
				<arg>[1] Forms</arg>
			</function>
			<function name="LCDDraw" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="LCDDrawLeft" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="LCDDrawRight" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="LCDInit" internal ="gnap" nbargs="0" return=""/>
			<function name="NewGraphic" internal ="gnap" nbargs="3" return="int">
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="NewHSLFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="NewRGBFrame" internal ="gnap" nbargs="0" return=""/>
			<function name="PrintText" internal ="gnap" nbargs="1" return="">
				<arg>string</arg>
			</function>
			<function name="ReadByte" internal ="gnap" nbargs="1" return="int">
				<arg>int</arg>
			</function>
			<function name="SendToCam" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SendToSapien" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetBluePixel" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SetConfigPobProto" internal ="gnap" nbargs="0" return=""/>
			<function name="SetConfigTinyPobProto" internal ="gnap" nbargs="0" return=""/>
			<function name="SetGraphicPixel" internal ="gnap" nbargs="3" return="">
				<arg>int</arg>
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SetGreenPixel" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SetIOWay" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetOutput" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPinPortA" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPinPortC" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPinPortD" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPortA" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPortC" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetPortD" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SetRedPixel" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>
			</function>
			<function name="SetServoMotor" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>	
			</function>
			<function name="Sin" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="Sqrt" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="SwitchOff" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SwitchOffAll" internal ="gnap" nbargs="0" return=""/>
			<function name="SwitchOn" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="SwitchOnAll" internal ="gnap" nbargs="0" return=""/>
			<function name="Tan" internal ="gnap" nbargs="1" return="float">
				<arg>float</arg>
			</function>
			<function name="UARTGet" internal ="gnap" nbargs="1" return="int">
				<arg>[1] int</arg>
			</function>
			<function name="UARTGetBuffer" internal ="gnap" nbargs="2" return="">
				<arg>[1] int</arg>
				<arg>int</arg>
			</function>
			<function name="UARTInit" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="UARTSend" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="UARTSendBuffer" internal ="gnap" nbargs="2" return="">
				<arg>[1] int</arg>
				<arg>int</arg>	
			</function>
			<function name="UART1Get" internal ="gnap" nbargs="1" return="int">
				<arg>[1] int</arg>
			</function>
			<function name="UART1GetBuffer" internal ="gnap" nbargs="2" return="">
				<arg>[1] int</arg>
				<arg>int</arg>
			</function>
			<function name="UART1Init" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="UART1Send" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="UART1SendBuffer" internal ="gnap" nbargs="2" return="">
				<arg>[1] int</arg>
				<arg>int</arg>	
			</function>
			<function name="Wait" internal ="gnap" nbargs="1" return="">
				<arg>int</arg>
			</function>
			<function name="WriteByte" internal ="gnap" nbargs="2" return="">
				<arg>int</arg>
				<arg>int</arg>
			</function>
		</pobeye2>
	</natives>
</grammar>







